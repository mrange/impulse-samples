// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4[12*12+2] v;"
 "const float m=.9/(12*.5),y=acos(-1),s=2*y,a=m;"
 "const vec2 n=vec2(.75,.075);"
 "const int[16] d=int[16](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "float t(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "vec3 x(vec2 v)"
 "{"
   "float m=.45-1/80.;"
   "vec2 f=v*v;"
   "f*=f;"
   "float y=m*m;"
   "y*=y;"
   "y*=y;"
   "float d=y-dot(f,f);"
   "if(d>0)"
     "{"
       "vec3 a=vec3(v,pow(d,1./8)),s=a*a,n=s*s;"
       "n*=s*a;"
       "return normalize(n);"
     "}"
   "return vec3(0,0,1);"
 "}"
 "float t(vec2 v,vec2 d)"
 "{"
   "v.x=abs(v.x);"
   "float y=max(d.x-d.y,0)/2;"
   "return(v.x<y?"
     "abs(v.y):"
     "length(v-vec2(y,0)))-d.y;"
 "}"
 "vec3 p(float v)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+v);"
 "}"
 "vec2 e(inout vec2 v)"
 "{"
   "vec2 y=vec2(.075,.1),m=floor((v+y/2)/y);"
   "v=mod(v+y/2,y)-y/2;"
   "return m;"
 "}"
 "vec3 e(vec3 v,vec2 y,vec3 m,vec3 a,float f,float p)"
 "{"
   "vec2 l=abs(y),s=y,x=y,r=sign(x),i=y;"
   "if(l.x>.5+n.y+.1||l.y>1+n.y+.1)"
     "return v;"
   "s.y-=1;"
   "float e=round(s.y);"
   "s.y-=e;"
   "x=abs(x);"
   "x=x.yx;"
   "x-=.5;"
   "i.y=abs(y.y);"
   "i.y-=.5;"
   "i=abs(i);"
   "float z=t(s,n),C=t(x,n),F=dot(normalize(vec2(1,-1)),i);"
   "return mix(v,(d[int(floor(p))]&1<<int(F>0?"
     "(r.x+1)/2+r.y+1+3:"
     "-e))==0?"
     "a:"
     "m,smoothstep(f,-f,min(z,C)));"
 "}"
 "void main()"
 "{"
   "vec2 y=v[0].yz,s=(-y+2*gl_FragCoord.xy)/y.yy,d=(-y+2*v[1].xy)/y.yy,n=s,m=s,i=s;"
   "d.y=-d.y;"
   "vec3 r=vec3(0),l=vec3(s,0),C=vec3(d,1),z=normalize(l-vec3(0,0,10)),F=normalize(C-l),J=normalize(vec3(2,3,3));"
   "float o=v[0].x,H=sqrt(2)/y.y,G=H/a,E=H/.04,D=H/(.25*a);"
   "m/=a;"
   "m-=.5;"
   "i.x-=-.075/2;"
   "i.y-=-.95;"
   "vec2 u=e(i),c=round(m);"
   "m-=c;"
   "c+=6;"
   "i/=.04;"
   "float A=c.x+c.y*12+2;"
   "vec4 B=v[int(A)];"
   "float g=B.x,I=B.z,K=t(m);"
   "vec3 L=x(m),M=sqrt(p(o));"
   "float N=1+dot(L,z);"
   "if(max(abs(n).x,abs(n).y)<.9)"
     "{"
       "vec3 O=r/4;"
       "vec2 P=vec2[6](vec2(0),vec2(.5,1),vec2(2),vec2(10,0),vec2(10,2),vec2(4,1))[int(g)];"
       "float Q=length(m);"
       "for(float R=0;R<P.y;++R)"
         "Q=min(abs(Q-.1),Q);"
       "vec3 R=(.2+p(2-g))*(P.x*.005/max(Q,.003));"
       "O=mix(O,R,smoothstep(G,-G,K));"
       "if(g<0)"
         "{"
           "vec2 S=m/.25;"
           "S.x+=-S.y/8;"
           "vec3 T=p(.33*g-.5*S.y);"
           "O=e(O,S,T,T*.075,D,-g);"
         "}"
       "vec3 T=p(3.5-s.y);"
       "O+=(pow(max(dot(J,reflect(z,L)),0.),20)/4+pow(max(dot(F,reflect(z,L)),0.),40)*M)*N*16.*step(1,g);"
       "r=mix(r,O,smoothstep(G,-G,K));"
       "K=abs(K)-1/80.;"
       "r=mix(r,mix(vec3(1),T/3,smoothstep(I+1/8.,I+.5,o)),smoothstep(G,-G,K));"
     "}"
   "if(u.y==0&&abs(u.x-.5)<5)"
     "{"
       "vec3 T=p(-4.*s.y+(u.x<1?"
         "0:"
         "3));"
       "r=e(r,i,T,T*.075,E,mod(o*pow(10,u.x),10));"
     "}"
   "r+=M*(.001/max(length(s-d),.001));"
   "f=vec4(sqrt(tanh(r)),1);"
 "}",

#endif

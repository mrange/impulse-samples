// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4[12*12+2] v;"
 "const float m=.9/(12*.5),y=acos(-1),s=2*y,a=m;"
 "vec2 n=vec2(.75,.075),r[6]=vec2[](vec2(0),vec2(.5,0),vec2(2),vec2(10,0),vec2(10,2),vec2(4,1));"
 "int d[16]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "float t(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "vec3 x(vec2 v)"
 "{"
   "float m=.45-1/80.;"
   "vec2 f=v*v;"
   "f*=f;"
   "float y=m*m;"
   "y*=y;"
   "y*=y;"
   "float n=y-dot(f,f);"
   "if(n>0)"
     "{"
       "vec3 a=vec3(v,pow(n,1./8)),s=a*a,r=s*s;"
       "r*=s*a;"
       "return normalize(r);"
     "}"
   "return vec3(0,0,1);"
 "}"
 "float t(vec2 v,vec2 n)"
 "{"
   "v.x=abs(v.x);"
   "float y=max(n.x-n.y,0)/2;"
   "return(v.x<y?"
     "abs(v.y):"
     "length(v-vec2(y,0)))-n.y;"
 "}"
 "vec3 p(float v)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+v);"
 "}"
 "vec2 e(inout vec2 v)"
 "{"
   "vec2 y=vec2(.075,.1),m=floor((v+y/2)/y);"
   "v=mod(v+y/2,y)-y/2;"
   "return m;"
 "}"
 "vec3 e(vec3 v,vec2 y,vec3 m,vec3 a,float f,float p)"
 "{"
   "vec2 l=abs(y),r=y,s=y,i=sign(s),x=y;"
   "if(l.x>.5+n.y+.1||l.y>1+n.y+.1)"
     "return v;"
   "r.y-=1;"
   "float e=round(r.y);"
   "r.y-=e;"
   "s=abs(s);"
   "s=s.yx;"
   "s-=.5;"
   "x.y=abs(y.y);"
   "x.y-=.5;"
   "x=abs(x);"
   "float z=t(r,n),C=t(s,n),F=dot(normalize(vec2(1,-1)),x);"
   "return mix(v,(d[int(floor(p))]&1<<int(F>0?"
     "(i.x+1)/2+i.y+1+3:"
     "-e))==0?"
     "a:"
     "m,smoothstep(f,-f,min(z,C)));"
 "}"
 "void main()"
 "{"
   "vec2 y=v[0].yz,s=(-y+2*gl_FragCoord.xy)/y.yy,n=(-y+2*v[1].xy)/y.yy,m=s,i=s,l=s;"
   "float d=v[0].x,C=v[0].w,F=sqrt(2)/y.y,z=F/a,w=F/.04,I=F/(.25*a);"
   "n.y=-n.y;"
   "vec3 c=vec3(0),G=vec3(s,0),E=vec3(n,1),D=normalize(G-vec3(0,0,10)),B=normalize(E-G),A=normalize(vec3(2,3,3)),g=sqrt(p(d));"
   "i/=a;"
   "i-=.5;"
   "l.x-=-.075/2;"
   "l.y-=-.95;"
   "vec2 o=e(l),H=round(i);"
   "i-=H;"
   "H+=6;"
   "l/=.04;"
   "float u=H.x+H.y*12+2;"
   "if(o.y==0&&abs(o.x-.5)<5)"
     "{"
       "vec3 J=p(-4.*s.y+(o.x<1?"
         "0:"
         "3));"
       "c=e(c,l,J,J*.075,w,mod(C*pow(10,o.x),10));"
     "}"
   "if(max(abs(m).x,abs(m).y)<.9)"
     "{"
       "vec4 J=v[int(u)];"
       "float K=J.x,L=J.z,M=t(i);"
       "vec3 N=x(i),O=c/4;"
       "vec2 P=r[int(K)];"
       "float Q=length(i);"
       "for(float R=0;R<P.y;++R)"
         "Q=min(abs(Q-.1),Q);"
       "vec3 R=(.2+p(2-K))*(P.x*.005/max(Q,.003));"
       "O=mix(O,R,smoothstep(z,-z,M));"
       "if(K<0)"
         "{"
           "vec2 S=i/.25;"
           "S.x+=-S.y/8;"
           "vec3 T=p(.33*K-.5*S.y);"
           "O=e(O,S,T,T*.075,I,-K);"
         "}"
       "vec3 T=p(3.5-s.y);"
       "O+=(pow(max(dot(A,reflect(D,N)),0.),20)/4+pow(max(dot(B,reflect(D,N)),0.),40)*g)*(1+dot(N,D))*16*step(1,K);"
       "c=mix(c,O,smoothstep(z,-z,M));"
       "M=abs(M)-1/80.;"
       "c=mix(c,mix(vec3(1),T/3,smoothstep(L+1/8.,L+.5,d)),smoothstep(z,-z,M));"
     "}"
   "c+=g*(.001/max(length(s-n),.001));"
   "f=vec4(sqrt(tanh(c)),1);"
 "}",

#endif

// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.fx
"#version 430\n"
 "uniform vec4 v;"
 "out vec4 f;"
 "const float s=acos(-1),c=.5*s,x=2*s;"
 "const int y=max(8,0);"
 "const float m=.25*float(12-y);"
 "float n()"
 "{"
   "return v.x;"
 "}"
 "vec2 t()"
 "{"
   "return v.yz;"
 "}"
 "mat2 n(float v)"
 "{"
   "float f=cos(v),y=sin(v);"
   "return mat2(f,y,-y,f);"
 "}"
 "vec4 n(vec4 v,vec4 f)"
 "{"
   "float y=f.w+v.w*(1.-f.w);"
   "return y>0.?"
     "vec4((f.xyz*f.w+v.xyz*v.w*(1.-f.w))/y,y):"
     "vec4(0);"
 "}"
 "vec3 n(vec3 v,vec4 f)"
 "{"
   "return mix(v,f.xyz,f.w);"
 "}"
 "float t(float v)"
 "{"
   "float f=v*v;"
   "return clamp(v*(27.+f)/(27.+9.*f),-1.,1.);"
 "}"
 "vec3 p(float v)"
 "{"
   "float f=v*.5;"
   "return vec3(-.25*(vec2(cos(f),sin(f*sqrt(2.)))+vec2(cos(f*sqrt(.75)),sin(f*sqrt(.6)))),v);"
 "}"
 "vec3 h(float v)"
 "{"
   "return(p(v+.05)-p(v-.05))/.1;"
 "}"
 "vec3 e(float v)"
 "{"
   "return(h(v+.05)-h(v-.05))/.1;"
 "}"
 "float e(float v,float f)"
 "{"
   "float y=c-f/(abs(f)+abs(v))*c;"
   "return v<0.?"
     "-y:"
     "y;"
 "}"
 "vec2 r(vec2 v)"
 "{"
   "return vec2(length(v),e(v.y,v.x));"
 "}"
 "vec2 l(vec2 v)"
 "{"
   "return vec2(v.x*cos(v.y),v.x*sin(v.y));"
 "}"
 "float h(inout float v,float f)"
 "{"
   "float y=f*.5,c=floor((v+y)/f);"
   "v=mod(v+y,f)-y;"
   "v*=mod(c,2.)*2.-1.;"
   "return c;"
 "}"
 "float l(float v,float f)"
 "{"
   "float y=clamp(.5+.5*(f-v)/.1,0.,1.);"
   "return mix(f,v,y)-.1*y*(1.-y);"
 "}"
 "float d(float v)"
 "{"
   "return-l(v,-v);"
 "}"
 "float d(inout vec2 v,float f)"
 "{"
   "vec2 y=v,c=r(y);"
   "float m=h(c.y,x/f),z=s/f-d(s/f-abs(c.y));"
   "c.y=sign(c.y)*z;"
   "y=l(c);"
   "v=y;"
   "return m;"
 "}"
 "vec3 d(vec3 v,vec2 f,float y,float m)"
 "{"
   "vec2 c=f,r=f;"
   "for(float w=0.;w<4.;w++)"
     "{"
       "r=fract(r*2.+.0125*y)-.5;"
       "float s=length(r)*exp(-length(c));"
       "vec3 l=(1.+cos(vec3(0,1,2)+x*(length(c)+w*.4+y*.2)))*.5;"
       "s=sin(s*8.+y)/8.;"
       "s=abs(s);"
       "s-=.0025;"
       "s=max(s,.005);"
       "s=.0125/s;"
       "s*=s;"
       "v+=l*s;"
     "}"
   "return.5*v;"
 "}"
 "vec3 d(vec2 v,float f,float y)"
 "{"
   "vec3 c=vec3(0);"
   "vec2 s=v;"
   "d(s,2.*floor(mix(3.,16.,.5+.5*sin(.1*y))));"
   "s+=.5*sin(vec2(1,sqrt(.5))*f*.21);"
   "c=d(c,s,f,y);"
   "c-=.75*vec3(0,1,2).zyx*dot(v,v);"
   "return clamp(c,0.,4.);"
 "}"
 "vec4 d(vec3 v,vec3 f,vec3 c,vec3 y,float m,float s)"
 "{"
   "vec2 r=(c-y*vec3(1,1,0)).xy;"
   "float w=length(r);"
   "r*=mix(.5,.75,.5+.5*sin(s*.071));"
   "float z=.0625*n()+.125*s;"
   "r*=n(-z);"
   "float i=smoothstep(.1,.15,w);"
   "if(i<.05)"
     "return vec4(0);"
   "vec4 l=vec4(0);"
   "l.xyz=d(r,z,s);"
   "float h=max(max(l.x,l.y),l.z)*.75;"
   "l.w=t(.5+w+max(h,0.))*i;"
   "return l;"
 "}"
 "float i(float v)"
 "{"
   "return.5+.5*cos(v);"
 "}"
 "vec3 d(vec3 v,vec3 f,vec3 s,vec3 c,vec2 m)"
 "{"
   "float r=length(m);"
   "vec2 l=m+1./t().xy;"
   "float w=1.75+.75*pow(r,1.5)*t(r+.9*i(10.*m.x)*i(10.*m.y));"
   "vec3 x=normalize(m.x*f+m.y*s+w*v),z=normalize(l.x*f+l.y*s+w*v);"
   "float h=floor(c.z/.25);"
   "vec4 a=vec4(0);"
   "bool e=false;"
   "float b=0.;"
   "for(int o=1;o<=12;++o)"
     "{"
       "float C=.25*h+.25*float(o),g=(C-c.z)/x.z;"
       "if(g>0.&&a.w<.975)"
         "{"
           "vec3 E=c+x*g;"
           "b=g;"
           "vec3 D=p(E.z);"
           "vec4 B=d(c,x,E,D,3.*length(E-c-z*g),h+float(o));"
           "float A=E.z-c.z;"
           "B.w*=smoothstep(0.,.025,A)*smoothstep(.25*float(12),.25*float(y),A);"
           "B=clamp(B,0.,1.);"
           "a=n(B,a);"
         "}"
       "else"
         "{"
           "e=true;"
           "a.w=a.w>.975?"
             "1.:"
             "a.w;"
           "break;"
         "}"
     "}"
   "return n(vec3(0),a);"
 "}"
 "vec3 d(vec2 v,vec2 f)"
 "{"
   "float y=.25*n();"
   "vec3 c=p(y),s=h(y),w=e(y),r=normalize(s),z=normalize(cross(normalize(vec3(0,1,0)+w),r)),x=d(r,z,cross(r,z),c,v);"
   "x*=smoothstep(0.,4.,n());"
   "x=clamp(x,0.,1.);"
   "return sqrt(x);"
 "}"
 "void main()"
 "{"
   "vec2 v=t(),s=gl_FragCoord.xy/v.xy,c=-1.+2.*s,y=c;"
   "c.x*=v.x/v.y;"
   "vec3 r=d(c,y);"
   "f=vec4(r,1);"
 "}",

#endif

// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4[12*12+2] v;"
 "const float a=.9/(12*.5),y=acos(-1),s=2*y,m=a;"
 "vec2 n=vec2(.75,.075),r[6]=vec2[](vec2(0),vec2(.5,0),vec2(2),vec2(10,0),vec2(10,2),vec2(4,1));"
 "int l[16]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "float t(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "vec3 x(vec2 v)"
 "{"
   "float a=.45-1./80;"
   "vec2 f=v*v;"
   "f*=f;"
   "float y=a*a;"
   "y*=y;"
   "y*=y;"
   "float m=y-dot(f,f);"
   "if(m>0)"
     "{"
       "vec3 n=vec3(v,pow(m,1./8)),s=n*n,r=s*s;"
       "r*=s*n;"
       "return normalize(r);"
     "}"
   "return vec3(0,0,1);"
 "}"
 "float t(vec2 v,vec2 m)"
 "{"
   "v.x=abs(v.x);"
   "float y=max(m.x-m.y,0)/2;"
   "return(v.x<y?"
     "abs(v.y):"
     "length(v-vec2(y,0)))-m.y;"
 "}"
 "vec3 d(float v)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+v);"
 "}"
 "vec2 p(inout vec2 v)"
 "{"
   "vec2 y=vec2(.075,.1),m=floor((v+y/2)/y);"
   "v=mod(v+y/2,y)-y/2;"
   "return m;"
 "}"
 "vec3 d(vec3 v,vec2 m,vec3 y,vec3 f,float d,float a)"
 "{"
   "vec2 p=abs(m),r=m,s=m,i=sign(s),x=m;"
   "if(p.x>.5+n.y+.1||p.y>1+n.y+.1)"
     "return v;"
   "r.y-=1;"
   "float o=round(r.y);"
   "r.y-=o;"
   "s=abs(s);"
   "s=s.yx;"
   "s-=.5;"
   "x.y=abs(m.y);"
   "x.y-=.5;"
   "x=abs(x);"
   "float z=t(r,n),C=t(s,n),F=dot(normalize(vec2(1,-1)),x);"
   "return mix(v,(l[int(floor(a))]&1<<int(F>0?"
     "(i.x+1)/2+i.y+1+3:"
     "-o))==0?"
     "f:"
     "y,smoothstep(d,-d,min(z,C)));"
 "}"
 "void main()"
 "{"
   "vec2 y=v[0].yz,s=(-y+2*gl_FragCoord.xy)/y.yy,n=(-y+2*v[1].xy)/y.yy,a=s,i=s,l=s;"
   "float C=v[0].x,F=v[0].w,o=sqrt(2)/y.y,z=o/m,w=o/.04,I=o/(.25*m);"
   "n.y=-n.y;"
   "vec3 c=vec3(0),G=vec3(s,0),E=vec3(n,1),D=normalize(G-vec3(0,0,10)),B=normalize(E-G),A=normalize(vec3(2,3,3)),g=sqrt(d(C));"
   "i/=m;"
   "i-=.5;"
   "l.x-=-.075/2;"
   "l.y-=-.95;"
   "vec2 u=p(l),H=round(i);"
   "i-=H;"
   "H+=6;"
   "l/=.04;"
   "float J=H.x+H.y*12+2;"
   "if(u.y==0&&abs(u.x-.5)<5)"
     "{"
       "vec3 K=d(-4.*s.y+(u.x<1?"
         "0:"
         "3));"
       "c=d(c,l,K,K*.075,w,mod(F*pow(10,u.x),10));"
     "}"
   "if(max(abs(a).x,abs(a).y)<.9)"
     "{"
       "vec4 K=v[int(J)];"
       "float L=K.x,M=K.z,N=t(i),O=smoothstep(M+1./2,M+1./8,C);"
       "vec3 P=x(i),Q=c/4;"
       "vec2 R=r[int(L)];"
       "float S=abs(length(i)-.1*O);"
       "for(float T=0;T<R.y;++T)"
         "S=min(abs(S-.1),S);"
       "vec3 T=(.2+d(2-L))*(R.x*.005/max(S,.003));"
       "Q=mix(Q,T,smoothstep(z,-z,N));"
       "if(L<0)"
         "{"
           "vec2 U=i/.25;"
           "U.x+=-U.y/8;"
           "vec3 V=d(L/2-U.y/2);"
           "Q=d(Q,U,V,V/20,I,-L);"
         "}"
       "vec3 V=d(3.5-s.y);"
       "Q+=(pow(max(dot(A,reflect(D,P)),0.),20)/4+pow(max(dot(B,reflect(D,P)),0.),40)*g)*(1+dot(P,D))*16*step(1,L);"
       "c=mix(c,Q,smoothstep(z,-z,N));"
       "N=abs(N)-1./80;"
       "c=mix(c,mix(V/3,vec3(1),O),smoothstep(z,-z,N));"
     "}"
   "c+=g*(.001/max(length(s-n),.001));"
   "f=vec4(sqrt(tanh(c)),1);"
 "}",

#endif

// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "v"
# define VAR_state "m"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 v;"
 "layout(location=0) uniform vec4[12*12+2] m;"
 "const float a=.9/(12*.5),y=a;"
 "const vec2 c=vec2(.75,.075);"
 "const int[16] H=int[16](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "const vec4 f=vec4(3,2,1,9)/3;"
 "vec3 s(vec3 v)"
 "{"
   "return v.z*mix(f.xxx,clamp(abs(fract(v.xxx+f.xyz)*6-f.www)-f.xxx,0,1),v.y);"
 "}\n"
 "#define HSV2RGB(c)(c.z*mix((vec4(3,2,1,9)/3).xxx,clamp(abs(fract(c.xxx+(vec4(3,2,1,9)/3).xyz)*6.0-(vec4(3,2,1,9)/3).www)-(vec4(3,2,1,9)/3).xxx,0.0,1.0),c.y))\n"
 "#define HSV2RGBT(c)vec4(HSV2RGB(c.xyz),c.w)\n"
 "const vec4[6] i=vec4[6](HSV2RGBT(vec4(0)),HSV2RGBT(vec4(.55,.7,1,.125)),HSV2RGBT(vec4(.4,.7,1,.5)),HSV2RGBT(vec4(0,0,1,1)),HSV2RGBT(vec4(0,.8,1,1)),HSV2RGBT(vec4(0,.8,.25,.5)));"
 "vec2 t(inout vec2 v)"
 "{"
   "vec2 y=vec2(.075,.1),H=floor((v+y*.5)/y);"
   "v=mod(v+y*.5,y)-y*.5;"
   "return H;"
 "}"
 "float s(vec2 v,vec2 y)"
 "{"
   "vec2 c=abs(v)-y;"
   "return length(max(c,0.))+min(max(c.x,c.y),0.);"
 "}"
 "float t(vec2 v,vec2 c)"
 "{"
   "v.x=abs(v.x);"
   "float y=.5*max(c.x-c.y,0);"
   "return(v.x<y?"
     "abs(v.y):"
     "length(v-vec2(y,0)))-c.y;"
 "}"
 "vec3 s(vec3 v,vec2 y,vec3 x,vec3 m,float f,float l)"
 "{"
   "vec2 a=abs(y),i=y,s=y,n=sign(s),r=y;"
   "if(a.x>.5+c.y+.1||a.y>1+c.y+.1)"
     "return v;"
   "i.y-=1;"
   "float w=round(i.y);"
   "i.y-=w;"
   "s=abs(s);"
   "s=s.yx;"
   "s-=.5;"
   "r.y=abs(y.y);"
   "r.y-=.5;"
   "r=abs(r);"
   "float z=t(i,c),B=t(s,c),d=dot(normalize(vec2(1,-1)),r);"
   "return mix(v,(H[int(floor(l))]&1<<int(d>0?"
     ".5*(n.x+1)+n.y+1+3:"
     "-w))==0?"
     "m:"
     "x,smoothstep(f,-f,min(z,B)));"
 "}"
 "void main()"
 "{"
   "vec3 c=vec3(0);"
   "vec2 f=m[0].yz,a=(-f+2*gl_FragCoord.xy)/f.yy,r=(-f+2*m[1].xy)/f.yy,x=a,H=a;"
   "float l=m[0].x,n=sqrt(2)/f.y,z=n/y,B=n/.04,d=n/(.25*y);"
   "r.y=-r.y;"
   "x/=y;"
   "x-=.5;"
   "H.x-=-.0375;"
   "H.y-=-.95;"
   "vec2 w=t(H),C=round(x);"
   "x-=C;"
   "C+=12*.5;"
   "H/=.04;"
   "int o=int(C.x+C.y*12+2);"
   "vec4 u=m[o];"
   "float g=u.x,F=u.z,E=s(a,vec2(.9)),e=s(x,vec2(.4))-.05;"
   "if(E<0.)"
     "{"
       "c+=s(vec3(.55,.5,.002))*(1./max(dot(x,x)+smoothstep(F+.125,F+3.,l),.001));"
       "vec2 A=x/.25;"
       "if(g<0)"
         "{"
           "vec3 D=s(vec3(.3+.3*g/9,.5,1));"
           "c=s(c,A,D,D*.1,d,-g);"
         "}"
       "else"
         "{"
           "vec4 D=i[int(g)];"
           "c=mix(c,D.xyz,smoothstep(z,-z,e)*D.w);"
         "}"
       "e=abs(e)-.0125;"
       "c=mix(c,vec3(1),smoothstep(z,-z,e));"
     "}"
   "if(w.y==0&&abs(w.x-.5)<5)"
     "{"
       "vec3 D=s(vec3(.95,.9,1));"
       "c=s(c,H,D,D*.1,B,mod(l*pow(10,w.x),10));"
     "}"
   "c+=s(vec3(.4,.5,.002))/max(length(a-r),.001);"
   "c=sqrt(c);"
   "v=vec4(c,1);"
 "}",

#endif

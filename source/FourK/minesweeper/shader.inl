// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4[12*12+2] v;"
 "const float a=.9/(12*.5),y=acos(-1),s=2*y,m=a;"
 "vec2 n=vec2(.75,.075),r[6]=vec2[](vec2(0),vec2(.5,0),vec2(2),vec2(10,0),vec2(10,2),vec2(4,1));"
 "int l[16]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "float t(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "vec3 t(vec2 v,float m)"
 "{"
   "vec2 f=v*v;"
   "f*=f;"
   "float a=m*m;"
   "a*=a;"
   "a*=a;"
   "float y=a-dot(f,f);"
   "if(y>0)"
     "{"
       "vec3 x=vec3(v,pow(y,1./8)),s=x*x,n=s*s;"
       "n*=s*x;"
       "return normalize(n);"
     "}"
   "return vec3(0,0,1);"
 "}"
 "float x(vec2 v,vec2 y)"
 "{"
   "v.x=abs(v.x);"
   "float f=max(y.x-y.y,0)/2;"
   "return(v.x<f?"
     "abs(v.y):"
     "length(v-vec2(f,0)))-y.y;"
 "}"
 "vec3 x(float v)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+v);"
 "}"
 "vec2 p(inout vec2 v)"
 "{"
   "vec2 y=vec2(.075,.1),f=floor((v+y/2)/y);"
   "v=mod(v+y/2,y)-y/2;"
   "return f;"
 "}"
 "vec3 p(vec3 v,vec2 y,vec3 f,vec3 m,float a,float d)"
 "{"
   "vec2 p=abs(y),s=y,r=y,i=sign(r),c=y;"
   "if(p.x>.5+n.y+.1||p.y>1+n.y+.1)"
     "return v;"
   "s.y-=1;"
   "float t=round(s.y);"
   "s.y-=t;"
   "r=abs(r);"
   "r=r.yx;"
   "r-=.5;"
   "c.y=abs(y.y);"
   "c.y-=.5;"
   "c=abs(c);"
   "float z=x(s,n),C=x(r,n),F=dot(normalize(vec2(1,-1)),c);"
   "return mix(v,(l[int(floor(d))]&1<<int(F>0?"
     "(i.x+1)/2+i.y+1+3:"
     "-t))==0?"
     "m:"
     "f,smoothstep(a,-a,min(z,C)));"
 "}"
 "void main()"
 "{"
   "vec2 y=v[0].yz,a=(-y+2*gl_FragCoord.xy)/y.yy,s=(-y+2*v[1].xy)/y.yy,n=a,c=a,i=a;"
   "float d=v[0].x,l=v[0].w,C=sqrt(2)/y.y,z=C/m,F=C/.04,w=C/(.25*m);"
   "s.y=-s.y;"
   "vec3 o=vec3(0),H=vec3(a,0),G=vec3(s,1),E=normalize(H-vec3(0,0,10)),D=normalize(G-H),B=normalize(vec3(2,3,3)),g=sqrt(x(d));"
   "c/=m;"
   "c-=.5;"
   "i.x-=-.075/2;"
   "i.y-=-.95;"
   "vec2 u=p(i),A=round(c);"
   "c-=A;"
   "A+=6;"
   "i/=.04;"
   "float I=A.x+A.y*12+2;"
   "if(u.y==0&&abs(u.x-.5)<5)"
     "{"
       "vec3 J=x(-4.*a.y+(u.x<1?"
         "0:"
         "3));"
       "o=p(o,i,J,J*.075,F,mod(l*pow(10,u.x),10));"
     "}"
   "if(max(abs(n).x,abs(n).y)<.9)"
     "{"
       "vec4 J=v[int(I)];"
       "float K=J.x,L=J.z,M=t(c),N=smoothstep(L+1./2,L+1./8,d);"
       "vec3 O=t(c,.45-1./80-N/40),P=o/4;"
       "vec2 Q=r[int(K)];"
       "float R=abs(length(c)-.1*N);"
       "for(float S=0;S<Q.y;++S)"
         "R=min(abs(R-.1),R);"
       "vec3 S=(.2+x(2-K))*(Q.x*.005/max(R,.003));"
       "P=mix(P,S,smoothstep(z,-z,M));"
       "if(K<0)"
         "{"
           "vec2 T=c/.25;"
           "T.x+=-T.y/8;"
           "vec3 U=x(K/2-T.y/2);"
           "P=p(P,T,U,U/20,w,-K);"
         "}"
       "vec3 U=x(3.5-a.y);"
       "P+=(pow(max(dot(B,reflect(E,O)),0.),20)/4+pow(max(dot(D,reflect(E,O)),0.),40)*g)*(1+dot(O,E))*16*step(1,K);"
       "o=mix(o,P,smoothstep(z,-z,M));"
       "M=abs(M)-1./80;"
       "o=mix(o,mix(U/3,vec3(1),N),smoothstep(z,-z,M));"
     "}"
   "o+=g*(.001/max(length(a-s),.001));"
   "f=vec4(sqrt(tanh(o)),1);"
 "}",

#endif

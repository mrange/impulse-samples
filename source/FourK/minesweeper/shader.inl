// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_fcol "f"
# define VAR_state "v"
#endif

#else // if SHADER_MINIFIER_IMPL

// C:\code\github\impulse-samples\source\FourK\minesweeper\shader.frag
"#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4[12*12+2] v;"
 "const float a=.9/(12*.5),y=acos(-1),s=2*y,m=a;"
 "vec2 x=vec2(.75,.075),r[6]=vec2[](vec2(0),vec2(.5,0),vec2(2),vec2(10,0),vec2(10,2),vec2(4,1));"
 "int d[16]=int[](125,80,79,87,114,55,63,81,127,119,123,62,45,94,47,43);"
 "float t(vec2 v)"
 "{"
   "v*=v;"
   "v*=v;"
   "return pow(dot(v,v),1./8)-.45;"
 "}"
 "vec3 t(vec2 v,float a)"
 "{"
   "vec2 f=v*v;"
   "f*=f;"
   "float y=a*a;"
   "y*=y;"
   "y*=y;"
   "float m=y-dot(f,f);"
   "if(m>0)"
     "{"
       "vec3 s=vec3(v,pow(m,1./8)),n=s*s,x=n*n;"
       "x*=n*s;"
       "return normalize(x);"
     "}"
   "return vec3(0,0,1);"
 "}"
 "float n(vec2 v,vec2 x)"
 "{"
   "v.x=abs(v.x);"
   "float m=max(x.x-x.y,0)/2;"
   "return(v.x<m?"
     "abs(v.y):"
     "length(v-vec2(m,0)))-x.y;"
 "}"
 "vec3 n(float x)"
 "{"
   "return 1+sin(vec3(-4,3,1)/2+x);"
 "}"
 "vec2 p(inout vec2 v)"
 "{"
   "vec2 x=vec2(.075,.1),f=floor((v+x/2)/x);"
   "v=mod(v+x/2,x)-x/2;"
   "return f;"
 "}"
 "vec3 n(vec3 v,vec2 y,vec3 m,vec3 f,float a,float l)"
 "{"
   "vec2 s=abs(y),i=y,r=y,p=sign(r),c=y;"
   "if(s.x>.5+x.y+.1||s.y>1+x.y+.1)"
     "return v;"
   "i.y-=1;"
   "float t=round(i.y);"
   "i.y-=t;"
   "r=abs(r);"
   "r=r.yx;"
   "r-=.5;"
   "c.y=abs(y.y);"
   "c.y-=.5;"
   "c=abs(c);"
   "float z=n(i,x),C=n(r,x),F=dot(normalize(vec2(1,-1)),c);"
   "return mix(v,(d[int(floor(l))]&1<<int(F>0?"
     "(p.x+1)/2+p.y+1+3:"
     "-t))==0?"
     "f:"
     "m,smoothstep(a,-a,min(z,C)));"
 "}"
 "vec3 p(vec2 v,float x)"
 "{"
   "vec3 f=vec3(0),s=vec3(0,0,x),y=normalize(vec3(v,2)),m=abs(y);"
   "float a=sign(y.x);"
   "for(int r=1;r<10;++r)"
     "{"
       "float t=(-s.x+6*sqrt(r))/m.x;"
       "vec3 p=s+y*t;"
       "vec2 l=p.yz*.02,d=round(l),i=l-d;"
       "if(fract(sin(dot((d+r+.5*sign(y.x)).xy,vec2(12.9898,58.233)))*13758.5453)<.5)"
         "i=vec2(i.y,-i.x);"
       "float c=smoothstep(-.7,1.,sin(.1*p.z+x+r+a)),z=length(i+.5)-.5,C=length(i-.5)-.5;"
       "f+=n(.05*t+x)*exp(-.003*t*t)*.0025/max(abs(abs(min(z,C))-.025),.003*c)*c;"
     "}"
   "return f;"
 "}"
 "void main()"
 "{"
   "vec2 x=v[0].yz,y=(-x+2*gl_FragCoord.xy)/x.yy,i=(-x+2*v[1].xy)/x.yy,s=y,a=y,c=y;"
   "float l=v[0].x,d=v[0].w,C=sqrt(2)/x.y,z=C/m,F=C/.04,w=C/(.25*m);"
   "i.y=-i.y;"
   "vec3 e=p(y,l),H=vec3(y,0),G=vec3(i,1),E=normalize(H-vec3(0,0,10)),D=normalize(G-H),B=normalize(vec3(2,3,3)),g=sqrt(n(l));"
   "a/=m;"
   "a-=.5;"
   "c.x-=-.075/2;"
   "c.y-=-.95;"
   "vec2 o=p(c),A=round(a);"
   "a-=A;"
   "A+=6;"
   "c/=.04;"
   "float u=A.x+A.y*12+2;"
   "if(o.y==0&&abs(o.x-.5)<5)"
     "{"
       "vec3 I=n(-4.*y.y+(o.x<1?"
         "0:"
         "3));"
       "e=n(e,c,I,I*.075,F,mod(d*pow(10,o.x),10));"
     "}"
   "if(max(abs(s).x,abs(s).y)<.9)"
     "{"
       "vec4 I=v[int(u)];"
       "float J=I.x,K=I.z,L=t(a),M=smoothstep(K+1./2,K+1./8,l);"
       "vec3 N=t(a,.45-1./80-M/40),O=tanh(8*e)/8;"
       "vec2 P=r[int(J)];"
       "float Q=abs(length(a)-.1*M);"
       "for(float R=0;R<P.y;++R)"
         "Q=min(abs(Q-.1),Q);"
       "vec3 R=(.2+n(2-J))*(P.x*.005/max(Q,.003));"
       "O+=R*smoothstep(z,-z,L);"
       "if(J<0)"
         "{"
           "vec2 S=a/.25;"
           "S.x+=-S.y/8;"
           "vec3 T=n(J/2-S.y/2);"
           "O=n(O,S,T,T/20,w,-J);"
         "}"
       "vec3 T=n(3.5-y.y);"
       "O+=(pow(max(dot(B,reflect(E,N)),0.),20)/4+pow(max(dot(D,reflect(E,N)),0.),40)*g)*(1+dot(N,E))*16*step(1,J);"
       "e=mix(e,O,smoothstep(z,-z,L));"
       "L=abs(L)-1./80;"
       "e=mix(e,mix(T/3,vec3(1),M),smoothstep(z,-z,L));"
     "}"
   "e+=g*(.001/max(length(y-i),.001));"
   "f=vec4(sqrt(tanh(e)),1);"
 "}",

#endif
